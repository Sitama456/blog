## 3.7 过程
过程是软件中一种很重要的抽象。提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。不同编程语言，过程的形式多样：函数(function)、方法(method)、子例程(subroutine)等等。
假设过程P调用过程Q，Q执行后返回到P。这些动作包含下面一个或多个机制：
- `传递控制`。 在进入过程Q的时候，程序计数器必须被设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面的那条指令的地址。
- `传递数据`。P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。
- `分配和释放内存`。在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。

x86-64的过程实现包括一组特殊的指令和一些对机器资源(例如寄存器和程序内存)使用的约定规则，只实现上述机制中每个过程所必需的那些。接下来，我们一步步地构建起不同的机制，先描述控制，在描述数据传递，最后是内存管理。

### 3.7.1 运行时栈
C语言函数调用机制的一个关键特性在于使用了栈数据结构提供的先进后厨的内存管理原则。当Q在执行时，P以及所有更早的函数都是暂时被挂起的。当Q运行，它只需要为局部变量分配新的存储空间，或者在调用另一个函数。当Q返回时，任何它所分配的局部存储空间都可以被释放。栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。当P调用Q，控制和数据信息添加到栈尾，当P返回时，这些信息会被释放掉。
![](pic/3.7%20过程/栈.png)
x86-64的栈向低地址方向增长，栈指针%rsp指向栈顶元素。可以用pushq或popq指令将数据存入栈中或取出。

当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的`栈帧(stack frame)`。每个过程栈帧的上边界和下边界就是%rbp和%rsp。栈帧随着过程的调用动态增成长或释放。当所有的局部变量都可以被保存在寄存器中时，就不需要栈帧。

### 3.7.2 转移控制
将控制从函数P转移到函数Q只需要设置程序计数器(PC)的值为Q的代码的起始地址。当稍后从Q返回的时候，处理器必须记录好它需要继续P的执行的代码位置。在x86-64中，这个动作是由指令`call Q` 调用过程Q来记录的。该指令会把`地址A`压入栈中，并将`PC`设置为Q的`起始地址`。压入的`地址A`被称为`返回地址`，是紧跟在`call`指令后面的那条指令的地址。对应的指令`ret`会从栈中弹出`地址A`，并把`PC`设置为`A`。
![](pic/3.7%20过程/call_ret.png)

一个main函数调用其他函数的例子：
![](pic/3.7%20过程/main_call_f.png)

### 3.7.3 数据传送
过程间的调用还存在参数的传递和返回值的传递。x86-64中，大部分的数据传送都是通过寄存器实现的，并且通过寄存器最多能传递6个整形(整数或指针)参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小，会根据参数在参数列表中的顺序为它们分配寄存器，可以通过64位寄存器适当的部分访问小于64位的参数。
![](pic/3.7%20过程/寄存器传参.png)

但是如果函数的参数太多，那么超出6个的部分就要通过栈来传递。假设`过程P`调用`过程Q`，有`n`个参数，并且 `n > 6`。那么P的栈帧必须要容纳`7~n`号参数的存储空间。`参数7`位于`栈顶`。通过栈传递参数时，所有的数据大小都向`8`的倍数对齐。之后程序就可以执行`call指令`将控制转移到`过程Q`。
![](pic/3.7%20过程/栈传递参数.png)
![](pic/3.7%20过程/栈上的参数.png)

### 3.7.4 栈上的局部存储
有些时候，局部数据必须存放在内存中，常见的情况包括：
- 寄存器不足够存放所有的本地数据。
- 对一个局部变量使用地址运算符'&'，因此必须能够为它产生一个地址。
- 某些局部变量时数组或结构，因此必须能够通过数组或结构引用被访问到。

一般来说，过程通过减小栈指针在栈上分配空间。分配的结果作为栈帧的一部分，标号位"局部变量"。
![](pic/3.7%20过程/过程调用传指针例子.png)

可以看到，在`调用函数caller`中，要给`被调函数swap_add`传递局部变量`arg1`和`arg2`的指针，所以必须在栈帧上为这两个局部变量分配空间。而局部变量`sum`由于没有用到它的地址，所以没有为它分配空间，而是保存在寄存器`%rax`中。并且在返回前通过`addq`指令，释放了分配的空间。

当传递的参数本身的大小不是8的倍数时，并不会为每个参数都分配8字节的空间，只需要栈帧的总空间是8的倍数即可。
![](pic/3.7%20过程/多地址参数.png)

对应的汇编代码为：
![](pic/3.7%20过程/多地址参数.s.png)

可以看到，`call_proc`的栈上先分配了`32`个字节给用到地址运算的局部变量。此时栈上的内存分配情况为：
![](pic/3.7%20过程/栈上内存分布.png)

### 3.7.5 寄存器中的局部存储空间
寄存器组时唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，但必须确保当一个过程(调用者)调用另一个过程(被调者)时，被调用者不会覆盖调用者稍后要用到的寄存器的值。x86-64采用了一组统一的寄存器使用惯例，所有的过程都必须遵循。

按照惯例，寄存器`%rbx、%rbp`和`%r12 ~ %r15`被划分为`被调者保存`寄存器。其他的寄存器，除了栈指针`%rsp`，都划分为`调用者保存`寄存器。
![](pic/3.7%20过程/调用者被调者保存寄存器示例.png)

### 3.7.6 递归过程
x86-64过程能够递归地调用它们自身，每个过程调用的栈帧都被保存在栈上，因此多个未完成调用的局部变量不会相互影响。
![](pic/3.7%20过程/递归调用示例.png)

### 小结
这一节介绍了过程，也就是函数的机器级实现：主要是用栈这一数据结构保存和恢复函数调用中所需要的程序信息和数据信息。每一个函数的栈上空间被称为栈帧，栈帧随着调用层级向下增长，并且当函数完成返回时动态释放。其中，要深入理解和掌握调用期间栈帧上的内存分布情况。