## 在机器级程序中将控制与数据结合起来
目前位置，我们已经分别讨论了机器级代码如何实现程序的控制部分和如何实现不同的数据结构。在本节，我们会看看数据和控制如何交互。首先，深入审视一下指针，它是C语言中最重要的概念之一。接下来，看看理解机器级程序如何帮助我们研究缓冲区溢出。

### 3.10.1 理解指针
指针式C语言的一个核心特色，以一种统一的方式引用不同的数据结构。
- 每个指针都对应一个类型。这个类型表明指针指向的是哪一类对象。通常，如果对象类型为$T$，那么指针的类型为$T *$。指针类型不是机器代码中的一部分，是C语言提供的一种抽象，帮助程序员避免寻址错误。
- 每个指针都有一个值。这个值是某个指定类型的对象地址。特殊的`NULL(0)`值表示该指针未指向任何地方，是一个`空指针`。
- 指针用$\And$运算符创建。`leaq指令`是设计用来计算内存引用的地址的，$\And$运算符的机器代码实现通常用这条指令完成。
- '*'操作符用于间接引用指针。其结果是一个值，它的类型与该指针类型一致。间接引用是用内存引用来实现的。
- 数组与指针紧密联系。一个数组的名字可以像要给指针变量一样引用(但是不能修改)。
- 将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。
- 指针也可以指向函数。这提供了一个很强大的存储和向代码传递引用的功能。这些引用可以被程序的某个其他部分调用。


### 3.10.3 内存越界引用和缓冲区溢出
C对数组引用不进行任何边界检查，而且局部变量和状态信息都存放在栈中。这两种情况结合到一起就能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，视图重新加载寄存器或指向ret指令是，就会出现严重错误。

一种常见的状态破坏称为`缓冲区溢出(buffer overflow)`。在栈中分配某个字符数组来保存一个字符串，但字符串的长度超出了为数组分配的空间。
![](pic/3.10%20程序与数据结合起来/栈缓冲区溢出.c.png)

可以看到，缓冲区只有8个字节。检查GCC产生的汇编代码，看看栈式如何组织的：
![](pic/3.10%20程序与数据结合起来/栈缓冲区溢出.s.png)

栈中的内存分布情况为：
![](pic/3.10%20程序与数据结合起来/栈内存分布.png)

可以看到，字符串到`23个字符`之前都没有严重的后果，但是超过之后，返回地址以及更多可能的保存状态会被破环，那么`ret指令`就导致程序跳转到一个意想不到的位置。

另外，缓冲区溢出的一个更加致命的使用就是让程序执行它本来执行不到的函数。在上面一个例子中，假设对返回指令的修改不是随意的，而是修改成一个可执行代码的地址，称为`攻击代码`，那么`ret指令`的效果就是跳转到攻击代码。

### 3.10.4 对抗缓冲区溢出攻击
1. 栈随机化。要想有目的地修改返回地址，就需要知道返回地址相对缓冲区的偏移。栈随机化的思想使得栈的位置在程序每次允许时都有变化，因此，即使许多机器都允许相同的代码，它们的栈地址时不同的。
2. 栈破坏检测。其思想时在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀值，也成为哨兵值，是在程序每次运行时随机产生大的。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被修改了。如果时，那么程序异常终止。
3. 限制可执行代码区域。思想时限制哪些内存区域能够存放可执行代码。

### 3.10.5 支持变长栈帧
目前位置的各种函数的机器级代码都有一个共同点：编译器能够预先确定需要为栈帧分配多少空间。但是有些函数，需要的局部存储时变长的。例如，当函数调用`alloca`在栈上分配任意字节数量的内存就会发生这种情况。

下面这个例子中，函数声明了n个指针的局部数组p，这里n有第一个参数给出。这要求在栈上分配8n个字节。编译器无法根据n的值确定要给该函数的栈帧分配多少空间，因为n时变量。
![](pic/3.10%20程序与数据结合起来/变长栈帧,c.png)
![](pic/3.10%20程序与数据结合起来/变长栈帧.s.png)

为了管理变长栈帧，x86-64代码使用寄存器`%rbp`作为帧指针。它是一个被调用者保存寄存器。
![](pic/3.10%20程序与数据结合起来/帧寄存器.png)

记录栈底指针`%rbp`主要是为了能够引用到`局部变量i`。因为`i`相对于`%rbp`的偏移是不变的，但是相对于`%rsp`的偏移是随着变量n变化的。

在较早版本的x86代码中，每个函数调用都使用了帧指针。而现在，只有栈帧长可变的情况下才使用。历史上，大多数编译器在生成IA32代码时会使用帧指针。最近的GCC版本放弃了这个惯例。

### 小结
本节介绍了C语言的指针的相关特性，它其实就对应于机器级代码中的内存地址，只不过在C语言中添加了类型的支持，而机器级代码中只是一个地址值。阐述了缓冲区太小导致溢出，修改了栈中的程序信息而导致的严重错误的现象，以及利用缓冲区溢出达到转移控制权的攻击方式。也介绍了应对这种攻击的相应措施。最后，说明了x86-64对可变栈帧的支持方式。