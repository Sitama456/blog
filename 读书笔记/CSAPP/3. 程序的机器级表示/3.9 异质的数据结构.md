## 3.9 异质的数据结构
C语言提供了两种将不同类型的对象组合到一起创建数据类型的机制：
- `结构(structrue)` 用关键字`struct`声明
- `联合(union)` 用关键字`union`声明
允许用几种不同的类型来引用一个对象。

### 3.9.1 结构
C语言的`struct`声明创建一个数据类型，将可能不同类型的对象聚合到一个对象中，用名字来引用结构的各个组成部分。结构的所有成员都放在内存中一段连续的区域内，指向结构的指针就是结构`第一个字节`的地址。编译器维护结构中每个`字段`的字节偏移。

考虑这样一个结构：
```c
    struct rec {
        int i;
        int j;
        int a[2];
        int *p;
    }
```
则它在内存中的分布情况为：
![](pic/3.9%20异质的数据结构/结构内存.png)

为了访问结构的字段，编译器产生的代码要将结构的地址加上适当的偏移。例如，假设`struct rec*`类型的变量`r`放在寄存器`%rdi`中，那么下面的代码将元素`r->i`复制到元素`r->j`:
```S
    movl (%rdi), %eax           ; 得到 r->i
    movl %eax, 4(%rdi)          ; 将 r->i 拷贝到 r->j
```

### 3.9.2 联合
联合声明语法于结构的语法一样，不过语义相差比较大。考虑下面的声明：
```c
    struct S3 {
        char c;
        int i[2];
        double v;
    }

    union U3 {
        char c;
        int i[2];
        double v;
    };
```
在x86-64的机器上编译时，它们的内存偏移为：
![](pic/3.9%20异质的数据结构/内存偏移.png)

可以看到，联合的所有字段的偏移量都是0。即这些字段共享一块内存，一个联合的总的大小等于它的最大字段的大小。在应用程序编程中，联合应该少用，但是在内核中它又必不可少，因为它能有效节约数据对象的大小。

### 3.9.3 数据对齐
许多计算机系统对基本数据类型的合法地址做了一些限制，要求某种类型对象的地址必须是某个值K（通常是2、4或8）的倍数。这种对齐限制简化了处理器和内存系统之间接口的硬件设计。比如，假设一个处理器总是从内存中取8个字节，则地址必须为8的倍数。如果能保证所有的double类型数据的地址对齐成8的倍数，就可以用一个内存操作来读或者写值了。否则，就可能需要执行两次内存访问，因为对象可能被分放在两个8字节内存块中。

对齐原则是任何K字节的基本对象的地址必须是K的倍数。
![](pic/3.9%20异质的数据结构/内存对齐表.png)

对于结构代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构单元都满足它的对齐要求，考虑这样的结构声明：
```c
    struct S1 {
        int i;
        char c;
        int j;
    }
```
假设按照最小的9字节分配，则其偏移情况为：
![](pic/3.9%20异质的数据结构/结构最小内存偏移.png)
但明显i和j是不能满足对齐要求的。所以，编译器会在c和j之间插入一个3字节的间隙：
![](pic/3.9%20异质的数据结构/结构对齐内存偏移.png)

### 小结
在机器及程序中，结构和联合就是一段连续的内存空间。不同的是，结构的内存空间大小是所有字段的总和，修改其中一个字段不会影响其他字段；而联合的内存空间大小是最大的字段的大小，并且所有字段共享这一块内存，所以修改其中一个字段，很可能会影响其他字段。本节还解释了关于内存对齐的内容，当对齐时能够简化硬件接口设计。