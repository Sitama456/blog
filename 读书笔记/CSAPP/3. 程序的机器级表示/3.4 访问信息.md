## 3.4 访问信息
一个x86-64的中央处理器单元(CPU)包含一组16个存储64位值的`通用目的寄存器`。这些寄存器用来存储整数数据和指针。它们的名字都已%r开头，后面还跟着一些不同的命名2规则的名字，这是由于指令集历史演化造成的。最初的8086中有8个16位的寄存器，从%ax到%bp。每个寄存器都有特殊的用途，它们的名字就反映了这些不同的用途。扩展到IA32架构时，这些寄存器也扩展成了32位寄存器，标号从%eax到%ebp。扩展到x86-64后，原来的8个寄存器扩展成64位，标号从%rax到%rbp。除此之外，还增加了8个新的寄存器，从%r8到%r15。
![](pic/3.4%20访问信息/寄存器.png)

### 3.4.1 操作数指示符
大多数指令有一个或多个`操作数(operand)`，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。x86-64支持的操作数形式被分为三种类型。
1. `立即数(immediate)` 用来表示常数值。比如，$-577或$0x1F。不同的指令运行的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。
2. `寄存器(register)` 表示某个寄存器的内容，16个寄存器的地位1字节、2字节、4字节或8字节中的一个作为操作数。
3. `内存引用` 根据计算出来的地址(通常称为有效地址)访问某个内存位置。将内存看成一个很大的字节数组，用符号$M_b[Addr]$表示对存储在内存中从地址$Addr$开始的$b$个字节值得引用，为简便通常省去下标b。

内存引用有多种不同得寻址模式，用语法$Imm(r_b, r_i, s)$表示得是最常用得形式。这样的引用有四个组成部分：一个立即数偏移$Imm$，一个基址寄存器$r_b$，要给变址寄存器$r_i$和一个比例因子$s$。$s$必须是1、2、4或者8。这样表示的有效地址被计算为$Imm + R[r_b] + R[r_i] * s$。引用数组元素时，会用到这种通用形式。
![](pic/3.4%20访问信息/寻址方式.png)

### 3.4.2 数据传送指令
最频繁使用的指令是2将数据从一个位置复制到另一个位置的指令。存在多种不同的数据传送指令，它们或者源和目的的类型不同，或者执行的转换不同，或者具有一些副作用不同。

最简单形式的数据传送指令是`MOV`类。这些指令把数据从源位置复制到目的位置，不做任何变化。`MOV`类由四条指令组成：`movb` `movw` `movl` `movq`。主要区别于它们操作的数据大小不同，分别是1、2、4和8字节。
![](pic/3.4%20访问信息/MOV类指令.png)

源操作数指定的值是一个`立即数`，存储在寄存器或者内存中。目的操作数指定一个`位置`，要么是一个`寄存器`，要么是一个`内存地址`。x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。寄存器部分的大小必须与指令最后一个字符(‘b’，‘w’，‘l’，‘q’)指定的大小匹配。

下面的MOV指令实例给出了源和目的类型的物种可能的组合，第一个是源操作数，第二个是目的操作数：
![](pic/3.4%20访问信息/mov操作数组合.png)

常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到64位的值，放到目的位置。movabsq指令能够以任意64位立即数作为源操作数，并且只能以寄存器作为目的。

MOVZ类中的指令把目的操作数中剩余的字节填充为0，而MOVS类中的指令通过符号扩展来填充。
![](pic/3.4%20访问信息/MOVZ类指令.png)
![](pic/3.4%20访问信息/MOVS类指令.png)

### 3.4.3 数据传送示例
考虑一个C语言的数据交换函数以及GCC编译产上的汇编代码：
![](pic/3.4%20访问信息/数据传送示例.png)

C函数的参数传递通过寄存器。当函数开始执行时，参数`xp`和`y`分别存储在寄存器`%rdi`和`%rsi`中。然后，指令2从内存中读出x，把它存放在寄存器`%rax`中，实现了C程序中$x=^*xp$。然后用寄存器`%rax`从这个函数返回一个值，因而返回值就是`x`，指令3将`y`写入到寄存器`%rdi`中的`xp`指向的内存位置，直接实现了操作$^*xp=y$。

### 3.4.4 压入和弹出栈数据
最后的两个数据传送操作可以将数据压入程序栈中，以及从程序栈中弹出数据。栈在处理函数调用中起到至关重要的作用。栈式一种后进先出的数据结构，通过`push`操作把数据压入栈中，通过`pop`操作删除数据。在x86-64中，程序栈存放在内存中的某个位置，并且栈是向下增长的，栈顶元素的地址是栈中所有元素最低的。
![](pic/3.4%20访问信息/入栈出栈操作.png)
`pushq`指令的作用是把数据压入到栈上，而popq指令是弹出数据。这些指令都只有一个操作数——压入的数据源和弹出的数据目的。
![](pic/3.4%20访问信息/栈操作实例.png)
因为栈和程序代码以及其他形式的程序数据都是放在同一内存中的，所以程序可以用标准的内存寻址方式访问栈内的任意位置。例如，假设栈顶元素是四字，指令movq 8(%rsp), %rdx会将第二个四字从栈中复制到寄存器%rdx。

### 小结
软件执行中重复着大量的数据传递，将一个数据从一个地方拷贝至另一个地方。x86-64提供了多种数据传送和访问指令。同一类指令的功能基本相同，区别在于在执行时操作数的大小，通常操作数有8位、16位、32位和64位，对应着字节、字、双字和四字，也对应着x86系列演化过程中寄存器位数变化。需要对这些指令十分掌握。

