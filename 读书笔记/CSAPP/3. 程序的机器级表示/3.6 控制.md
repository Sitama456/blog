## 3.6 控制
目前为止，只考虑了直线代码的行为，即指令是按顺序执行的。但C语言中的某些结构，比如条件语句、循环语句和分支语句，要有条件的执行，根据数据测试的结果来决定操作执行的顺序。机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，指令跳转。

### 3.6.1 条件码
CPU维护者一组单个位的`条件码(condition code)寄存器`，描述了最近的算术或逻辑操作的属性，可以检测这些寄存器来执行条件分支语句：
- `CF`: 进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。
- `ZF`: 零标志。最近的操作得出的结果为0。
- `SF`: 符号标志。最近的操作得到的结果为负数。
- `OF`: 溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出。

leaq指令不改变任何条件码，因为它是用来进行地址计算的。除此之外，3.5节的所有指令都会设置条件码。

还有两类指令(有8、16、32和64位形式)，它们只设置条件码而不改变其他任何寄存器。
![](pic/3.6%20控制/比较和测试指令.png)
`CMP`指令根据两个操作数之差来设置条件码。除了只设置条件码而不更新目的寄存器之外，`CMP`指令和`SUB`指令的行为是一样的。如果两个操作数相等，这些指令会将`零标志设置位1`，而其他的标志可以用来确定两个操作数的大小关系。`TEST`指令的行为于`AND`指令一样，除了它只设置条件码而不改变目的寄存器的值。

### 3.6.2 访问条件码
条件码通常不会直接读取，常用的使用有三种：1）根据条件码的某种组合，将一个字节数值位0或者1，2）可以条件跳转到程序的某个其他的部分，3）可以有条件地传送数据。将一个字节设置位0或者1的这类指令称为`SET`指令。它们之间的区别就在于它们考虑的条件码的组合是什么。这些指令的后缀表示不同的条件而不是操作数大小。例如，指令`setl`和`setb`表示"小于时设置(set less)"和"低于时设置(set below)"。

一条`SET`指令的目的操作数时低位单字节寄存器元素之一，或是一个字节的内存位置。指令会将这个字节设置成0或1。为了得到一个32位或64位结果，必须对高位清零。
![](pic/3.6%20控制/SET指令.png)
![](pic/3.6%20控制/set示例.png)

### 3.6.3 跳转指令
正常情况下，指令按照它们在内存的顺序一条一条执行。`跳转(jump)`指令会导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个`标号(label)`指明。
![](pic/3.6%20控制/jump指令.png)
在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将`跳转目标`(目的指令的地址)编码位跳转指令的一部分。

jmp指令是无条件跳转。它可以是`直接跳转`，即跳转目标作为指令的一部分编码；也可以是`间接跳转`，即跳转目标是从寄存器或内存位置中读出的。汇编中是给出一个标号作为跳转目标的。
![](pic/3.6%20控制/jump类指令.png)

### 3.6.4 跳转指令的编码
在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器2，会产生跳转目标的适当编码。跳转指令有几种不同的编码，但是最常用的都是`相对PC编码`。它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编码位1、2或4个字节。第二种编码是给出绝对地址，用4个字节直接指定目标。汇编器和链接器会选择适当的跳转目的编码。
下面是一个PC相对寻址的例子，汇编程序为：
![](pic/3.6%20控制/PC相对寻址.s.png)
对应的目标代码文件为：
![](pic/3.6%20控制/PC相对寻址.o.png)

第2行的跳转指令的跳转目标指明为0x8，第5行的跳转指令的跳转目标为0x5。但观察第2行的跳转指令，其目标编码为(在第二个字节中)0x03。把它加上0x5，也就是下一条指令的地址，就得到条状目标地址0x8了。

类似，第5行的跳转指令的目标单字节、补码表示编码为0xf8(十进制-8)。将这个数加上0xd(十进制13)，即6行指令的地址，就得到0x5。

这个例子说明，当执行PC相对寻址时，程序计数器的值时跳转指令后面的那条指令的地址，而不是跳转指令本身。当链接完之后：
![](pic/3.6%20控制/链接后的PC相对地址.png)
这些指令被重定位到不同的地址，但第2行和第5行中跳转目标的编码并没有变。

### 3.6.5 用条件控制来实现条件分支
将条件表达式和语句从C语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转。一个计算两数之差绝对值的函数的C代码，GCC产生的汇编代码如图所示。把这个机器代码再转换成C语言，使用了C语言中的`goto`语句。
![](pic/3.6%20控制/goto.png)
C语言中if-else语句的通用形式模板如下：
```c
if(test-expr)
    then-statement
else
    else-statment
```
对于这种形式，汇编实现通常会使用下面的形式：
```c
t = test-expr;
if(!t)
    goto false
then-statement
goto done;
false:
    else-statement
done:
```
汇编器为`then-statement`和`else-statement`产生各自的代码块，会插入条件和无条件分支。

### 3.6.6 用条件传送来实现条件分支
基于控制的条件转移，再现代处理器上，可能会非常低效。一种替代的策略是使用数据的条件转移。这种方法计算一个条件操作的`两种结果`，然后再根据条件是否满足从中选取一个。只有在一些受限制的情况中，这种策略才可行。
![](pic/3.6%20控制/条件传送.png)

处理器通过使用`流水线(pipelining)`来获得高性能。在流水线中，一条指令的处理要经过一系列的阶段（例如，从内存中取指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据、以及更新程序计数器）。这种方法通过重叠连续指令的步骤来获得高性能。例如，在取一条指令的同时，执行它前面一条指令的算术运算。要做到这一点，就要求事先确定要执行的指令序列，这样才能保持流水线中充满待执行的指令。当机器遇到条件跳转时，只有当分支条件求值完成后，才能决定往哪走。
处理器采用非常精密的`分支预测逻辑`来猜测会走那条分支，只要它的猜测比较可靠(现代微处理器设计视图达到90%以上的成功率)，指令流水线中就会充满待执行指令。另一方面，如果处理器预测错误了，就要求它丢弃为该跳转指令后所有指令已做的工作。这样一个错误预测会招致很严重的惩罚，浪费大约15~30个时钟周期，导致程序性能严重下降。

下图列举了一些x86-64的条件传送指令。每条指令有两个操作数：源寄存器或者内存地址S，和目的寄存器R。这些指令的结果取决于条件码的值。源值可以从内存或者源寄存器中读取，但是只有在指定的条件满足时，才会被复制到目的寄存器。

源和目的的值可以是16位、32位或64位长。不支持单字节的条件传送。汇编器可以从目标寄存器的名字推断出条件传送指令的操作数长度。
![](pic/3.6%20控制/条件传送指令.png)
基于条件传送的代码可以表示为：
![](pic/3.6%20控制/条件传送代码.png)

### 3.6.7 循环
C语言提供了多种循环结构，即do-while、while和for。汇编中可以用条件测试和跳转组合起来实现循环的效果。
1. `do-while 循环` 其通用形式为：
   ```c
   do
        body-statement
        while (test-expr)
   ```
   翻译成goto版本就是：
   ```c
   loop:
        body-statement
        t = tset-expr;
        if (t)
            goto loop;
   ```
   具体实现示例为：
   ![](pic/3.6%20控制/do-while.png)

2. `while 循环` 其通用形式为：
   ```c
   while (test-expr)
        body-statement
   ```
   翻译成goto版本：
   ```c
   goto test;
   loop:
        body-statement
   test:
        t = test-expr;
        if (t)
            goto loop;
   ```
   具体实现示例：
   ![](pic/3.6%20控制/while.png)

   第二种翻译方法，称之为guarded-do。首先用条件分支，如果初始条件不成立就跳过循环，把代码变换成do-while循环。其goto模板为:
   ```c
   t = test-expr;
   if (!t)
        goto done;
   loop:
        body-statement
        t = test-expr
        if (t)
            goto loop
   done:
   ```
   具体实现示例为：
   ![](pic/3.6%20控制/guarded-do_goto.png)
   ![](pic/3.6%20控制/guarded-do_s.png)


3. `for 循环` 其通用形式为：
   ```c
   for (init-expr; test-expr; update-expr)
        body-statement
   ```
   这样一个循环与下面使用`while`循环的行为一样:
   ```c
   init-expr;
   while (test-expr)
        body-statement
        update-expr
   ```
   第一种翻译会得到如下goto代码：
   ```c
   init-expr
   goto test;
   loop:
        body-statement
        update-expr
   test:
        t = test-expr;
        if (t)
            goto loop;
   ```
   而guarded-do策略将得到：
   ```c
   init-expr
   t = test-expr;
   if (!t)
        goto done;
   loop:
        body-statement
        update-expr
        t = test-expr;
        if (t)
            goto loop
   done:
   ```

### 3.6.8 switch 语句
switch语句可以根据一个整数索引值进行多重分支。通过使用`跳转表(jump table)`使得这种数据结构实现的更加高效。跳转表是一个数值，表项i是一个代码段的地址。

对于C语言switch的描述如下图：
![](pic/3.6%20控制/switch_c.png)
在汇编代码中，同样通过表达式的值跳转到相应的代码块。
![](pic/3.6%20控制/switch_s.png)
在汇编代码中，跳转表用以下声明表示：
![](pic/3.6%20控制/jump-table.png)

### 小结
本节的信息量巨大，在C语言中可能几句代码就可以实现的代码结构，在机器级代码上却要数十行。机器级代码实现的控制主要依赖于条件判断指令和跳转指令。在实现某一个C语言代码结构时，可以先写出它的goto版本的代码结构，然后再将goto代码转换成机器级代码。