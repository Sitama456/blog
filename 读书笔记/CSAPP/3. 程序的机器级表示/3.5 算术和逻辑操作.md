## 3.5 算术和逻辑操作
图示的整数和逻辑操作，大多被分成了指令类，这些指令类有各种带不同大小操作数的变种（只有leaq没有其他大小的变种）。这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。二元操作数有两个操作数，一元2操作数有一个操作数。
![](pic/3.5%20算术和逻辑操作/整数和逻辑操作.png)

### 3.5.1
`加载有效地址(load effective address)`指令`leaq`实际上是`movq`指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。例如，如果寄存器`%rdx`的值为x，那么指令`leaq 7(%rdx, %rdx, 4), %rax`将设置寄存器`%rax`的值为`5x+7`。

### 3.5.2 一元和二元操作
第二组中的操作是一元操作，只有一个操作数，既是源又是目的。操作数可以是一个寄存器，也可以是一个位置。比如，指令`incq (%rsp)`会使栈顶的8字节元素加1。类似于C语言的++和--操作。

第三组是二元操作，其中，第二个操作数既是源又是目的。类似于C语言中的`x-=y,x+=z`。不过，源操作数是第一个，目的操作数是第二个。比如，指令`subq %rax, %rdx`使寄存器`%rdx`的值减去`%rax`中的值。第一个操作数可以是立即数、寄存器或是内存位置。第二个操作数可以是寄存器或是内存位置。注意，当第二个操作数是内存地址时，处理器会从内存读出值，执行操作，再写回内存。

### 3.5.3 移位操作
最后一组是移位操作，先给出移位量，然后第二项给出的是要移位的数。可以进行算数和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器`%cl`中。移位操作对$w$位长的数据值进行操作，移位量有%cl寄存器的低$m$位决定的，这里$2^m=w$。高位被忽略。例如当寄存器`%cl`的十六进制值为`0xFF`时，指令`salb`会移7位，`salw`会移15位，`sall`会移31位，而`salq`会移63位。

左移指令有两个名字：`SAL`和`SHL`。两者效果是一样的，都是在右边填上0。右移指令不同，`SAR`执行算术移位(填上符号位)，`SHR`执行逻辑移位(填上0)。移位操作的目的操作数可以是一个寄存器或是一个内存位置。

### 3.5.4
大多数指令，既可以用于无符号运算，也可以用于补码运算。只有右移操作要求区分有符号数和无符号数。这个特性使得补码运算成为实现有符号整数运算的一种比较好的方法的原因之一。

### 3.5.5 特殊的算术操作
两个64位有符号或无符号整数相乘得到的乘积需要128位来表示。x86-64指令集对128位(16字节)数的操作提供有限的支持。Intel把16字节数成为`八字(oct word)`。
![](pic/3.5%20算术和逻辑操作/8字乘除法.png)

### 小结
对于嵌入式工程师而言，掌握机器级代码十分重要。本节主要介绍了x86-64中主要的算术和逻辑操作。并且也说明了一个问题：在机器眼中，只存在一个按字节排列的巨大数组，而不管其中元素的具体含义，无论它是无符号数、有符号数还是其他。所以，x86-64只会提供相应的指令，比如逻辑右移和算术右移，具体要执行哪条语句还是要靠软件(编译器)来显示给出。