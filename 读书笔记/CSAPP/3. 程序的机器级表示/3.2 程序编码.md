## 3.2 程序编码 
还记得在计算机漫游中，GCC将源文件`hello.c`编译成可执行程序`hello`的过程吗？再来复习一遍，假设一个C程序，有两个文件p1.c和p2.c。用GCC编译的命令是：
```s
gcc -Og -o p p1.c p2.c
```
这里不再赘述相关参数的含义。实际上gcc命令调用了一整套的程序。
1. C预处理器扩产源代码，处理所有`#`开头的代码，比如`#include` `#define`。
2. 编译器产生两个源文件的汇编代码，分别位p1.s和p2.s。
3. 汇编器将汇编代码转化成二进制的目标代码文件p1.o和p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示。
4. 链接器将两个目标文件与实现库函数的代码合并，产设最终的可执行文件p。


### 3.2.1 机器级代码
对机器级编程而言，两种抽象尤为重要。第一种是`指令集体系结构或指令级架构(Instruction Set Architecture, ISA)`来定义机器级程序的格式和行为。它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA，包括`x86-64`，将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条指令才开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体的行为与ISA指定的顺序执行行文完全一致。第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。

x86-64的机器代码中，一些通常对C语言程序员隐藏的处理器状态都是可见的：
- `程序计数器`(通常称为“PC”，在x86-64中用 %rip 表示)给出将要执行的下一条指令在内存中的地址。
- `寄存器` 共有16个，分别存储64位的值。这些寄存器可以存储地址(C语言的指针)或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如函数的参数和局部变量，以及函数的返回值。
- `条件码寄存器`保存着最近执行的算数或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现`if`和`while`语句。
- `一组向量寄存器`可以存放一个或多个整数或浮点数值。

在机器代码中，只是简单地将内存看成一个很大的、按字节寻址的数组。汇编代码不区分有符号或无符号整数，不区分各种类型的指针，甚至于不区分指针和整数。

程序内存一般包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理函数掉和返回的运行时栈，以及用户分配的内存块。程序内存用虚拟地址来寻址，在任意给定的时刻，只有有限的一部分虚拟地址被认为是合法的。由操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。

### 3.2.2 代码示例
假设一个C语言代码文件`mstore.c`，包含如下的函数定义：
```c
long mult2(long, long);

void multstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
```
使用`-S`选项，就能看到C语言编译器产生的汇编代码:
```s
gcc -Og -S mstore.c
```
得到一个文件`mstore.s`，但是不做其他进一步的工作。汇编代码文件中包含各种声明，包括下面几行：
![](pic/3.2%20程序编码/mstore.s.png)
上述一行代表一条机器指令，如果使用`-c`命令行选项：
```s
gcc -Og -c mstore.c
```
就会产生目标代码文件`mstore.o`，它是二进制格式的。其中有一段14字节的序列，它的十六进制表示为：
```s
    53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
```
使用`反汇编器`可以查看其汇编格式的代码：
```s
objdump -d mstore.o
```
可以看到：
![](pic/3.2%20程序编码/mstore.o.png)
按照前面给出的字节顺序排列的14个十六进制字节值，被分成了若干组，每组有1~5个字节。每组都是一条指令，右边是等价的汇编语言。其中一些关于机器代码和它的反汇编表示的特性值得注意：
- x86-64的指令长度从1到15个字节不等。常用的指令以及操作数较小的指令所需的字节数少，而那些不太常用或操作数较多的指令所需的字节数较多。
- 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令 pushq %rbx 是以字节值53开头的。
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。

假设在文件`main.c`中这样定义：
![](pic/3.2%20程序编码/main.c.png)
然后生成可执行文件`prog`：
```s
gcc -Og -o prog main.c mstore.c
```
用反汇编器抽取出下面这段代码序列：
![](pic/3.2%20程序编码/prog.png)
这段代码与`mstore.c`反汇编生成的代码几乎完全一样。主要的区别是左边列出的地址不同，第二个不同是连接器填上了`callq`指令调用函数`mult2`需要使用的地址。可以看出，连接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。最后一个区别是多了两行代码，插入这些指令是为了使函数代码变为16字节，使得就存储器系统性能而言，能更好地放置下一个代码块。


### 3.3 数据格式
Intel用术语“字”表示16位数据类型。称32位数为“双字”，成64位数为“四字”。
![](pic/3.2%20程序编码/数据类型.png)
大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。比如，数据传送指令：movb(传送字节)、movw(传送字)、movl(传送双字)、movq(传送四字)。后缀‘l’用来表示双字，因为32位数被看作“长字(long word)”。注意，汇编代码也使用‘l’来表示8字节双精度浮点数。这不会产上歧义，因为浮点数使用的是一组完全不同的指令和寄存器。

### 小结
本节介绍了C源文件如何变成机器执行的二进制代码，以及对应于二进制代码的文本表示——汇编语言文件。汇编程序包含大量的机器指令，每条指令只执行简单的低级的具体功能。掌握常用的机器指令是阅读和编写汇编程序的关键。