## 6.3 存储器层次结构
前面两节描述了存储技术和计算机软件的一些基本的和持久的属性：
- 存储技术：不同存储技术的访问时间差异很大。速度较快的技术每字节的成本要比速度较慢的技术高，而且容量较小。CPU和主存之间的速度差距在增大。
- 计算机软件：一个编写良好的程序倾向于展示良好的局部性。

硬件和软件的这些基本属性互相补充得很完美。它们这种相互补充得很完美。这种互补得性质使得人们想到一种组织存储器系统的方法，称为`存储器层次结构(memory hierarchy)`，所有得现代计算机系统中都使用了这种方法。一般而言，从高层往底层走，存储设备变得更慢、更便宜和更大。
![](pic/6.3%20存储器层次结构/存储器层次结构.png)

### 6.3.1 缓存
一般而言，`高速缓存(cache)`是一个小而快速的存储设备，它作为存储在更大、也更慢的设备中的数据对象的缓冲区域。

中心思想是对于每个k，位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。层次结构中的每一层缓存来自较低一层的数据对象。在下图中，第k+1层的存储器被划分成连续的数据对象组块(chunk)，称为块(block)。每个块都有一个唯一的地址或名字，使之区别于其他的块。块大小可以是固定的(通常是这样的)，也可以是可变大小的。
![](pic/6.3%20存储器层次结构/存储器缓存原理.png)
类似地，第k层的存储器被划分成较少的块的集合，每个块的大小与k+1层的块的大小一样。数据总是以块大小为`传送单元(transfer unit)`在第k层和第k+1层之间来回复制的。虽然在层次结构中任何一对相邻的层次之间的大小是固定的，但是其他的层次对之间可以有不同的块大小。L1和L0之间传送通常使用的是一个字大小的块。L2和L1的传送通常使用几十个字节的块。L5和L4之间传送用的是几百或几千字节的块。

**1. 缓存命中**
当程序需要第k+1层的某个数据对象d是，它首先在第k层的一个块中查找d。如果d刚好缓存在第k层中，就是`缓存命中(cache hit)`。该程序直接从第k层读取d。

**2. 缓存不命中**
另一方面，如果第k层中没有数据对象d，就是`缓存不命中(cache miss)`。当发生缓存不命中时，第k层的缓存从第k+1层缓存中取出包含d的那个块，如果第k层的缓存已经满了，可能就会覆盖现存的一个块。

覆盖一个现存的块称为`替换(replacing)`或`驱逐(evicting)`这个块。决定替换哪个块是由缓存的`替换策略(replacement policy)`来控制的。一个具有随机替换策略的缓存会随机选择一个牺牲块。一个具有最近最少被使用(LRU)替换策略的缓存会选择那个最后被访问的时间距现在最远的块。

**3. 缓存不命中的种类**
如果第k层的缓存是空的，那么对任何数据对象的访问都不会命中。一个空的缓存有时被称为`冷缓存(cold cache)`，此类不命中称为`强制性不命中(compulsory miss)`或`冷不命中(cold miss)`。冷不命中通常是短暂的时间，不会再反复访问存储器使得`缓存暖身(warmed up)`之后的稳定状态中出现。

只要发生了不命中，第k层的缓存就必须执行某个`放置策略(placement policy)`，确定把它从第k+1层中取出的块放在哪里。最灵活的替换策略是允许来自第k+1层的任何块放在第k层的任何块中。对于存储器层次结构中高层的缓存，它们是用硬件来实现的，而且速度是最优的，这个策略实现起来通常很昂贵，因为随机地方志块，定位起来代价很高。