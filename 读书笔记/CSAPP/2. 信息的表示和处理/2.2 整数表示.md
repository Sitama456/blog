## 2.2整数表示
编码整数的两种不同的方式：一种只能表示非负数，另一种能够表示负数、零和整数。

### 2.2.1 整数数据类型
C语言支持多种整形数据类型来表示有限范围的整数。在32位机器上的整数类型可表示的范围为：
![](pic/2.1%20信息存储/32位C语言整数类型.png)

在64位机器上的整数类型可表示的范围为：
![](pic/2.1%20信息存储/64位C语言整数类型.png)

值得注意的特点是取值范围不是对称的——负数的范围比正数的范围大1.

### 2.2.2 无符号数的编码
假设一个整数数据类型有$w$位。其位向量$\vec{x}$可以写成$[x_{w-1}, x_{w - 2}, \cdots, x_0]$，表示向量中的每一位。用一个函数$B2U_w$(Binary to Unsigned的缩写，长度位$w$)来表示其数值：
$$
B2U_w(\vec{x})=\sum_{i=0}^{w-1} x_i2^i
$$
其中 $\vec{x}=[x_{w-1}, x_{w - 2}, \cdots, x_0]$

### 2.2.3 补码编码
对于有符号数的表示，最常见的方式就是`补码`形式。在这个定义中，将字的最高有效位解释为`负权`。用函数$B2T_w$(Binary to Two's-complement 的缩写，长度位$w$)来表示：
$$
B2T_w(\vec{x})=-x_{w-1}2^{w-1} + \sum_{i=0}^{w-2} x_i2^i
$$
其中 $\vec{x}=[x_{w-1}, x_{w - 2}, \cdots, x_0]$

### 2.2.4 有符号数和无符号数之间的转换
**无论怎么转换，只有一个原则，保持位模式不变**。
对于C语言程序：
![](pic/2.1%20信息存储/C语言强制转换.png)
在一台采用补码的机器上，上述代码会产上如下输出：
```c
v = -12345, uv = 53191
```
而这两个数的位模式是一样的。

### 2.2.5 C语言中的有符号数和无符号数
通常，大多数数字都默认位是有符号的，例如$12345$是有符号数，$12345U$是无符号数。无符号数要加上后缀'U'或'u'。
C语言允许有无符号数的隐式转换，例如：
```c
int tx, ty;
unsingned ux, uy;
tx = ux;  // 转换成有符号数
uy = ty;  // 转换成无符号数
```
对于一些比较运算符，隐式转换则表现得不那么直观，有时会出现意想不到得结果：
![](pic/2.1%20信息存储/比较运算符隐式转换.png)

### 2.2.6 扩展一个数字得位标识
一个常见得操作是在不同字长得整数之间转换，同时又保持数值不变。当然，当目标数据类型太小以至于不能表示想要得值时，这根本是不可能得。然而，从一个较小得数据类型转换成一个较大得数据类型，应该总是可能得。
对于无符号数得小数据类型转大数据类型，只需要在开头添加0，这中运算被称为`零扩展`。
对于补码数字转换位一个更大得数据类型，可以执行一个`符号扩展`，在开头添加最高有效位得值。因为补码1111和111以及111和1表示得值都是-1。

### 2.2.7 截断数字
假设不用额外得位来扩展一个数值，而是减少表示一个数字的位数，比如
```C
int x = 53191;
short sx = (short) x;       // -12345
int y = sx;                 // -12345
```
当把x强制转换为short时，就将32位得int截断位16位的short。
当一个$w$位的数$\vec{x}=[x_{w-1}, x_{w-2},\cdots, x_0]$截断为一个k位数字时，我们会丢弃高$w - k$位，得到一个位向量$\vec{x_{new}} = [x_{k-1}, x{k-2}, \cdots, x_0]$。截断一个数可能会改变它的值——溢出的一种形式。

### 小结
上节说过，每个字节或者说信息就是一串比特，对这串比特加以特定的解释才能代表具体的信息。无符号和有符号整数就是一种特定的解释，它们之间的区别也在于对比特串的解释不同。有符号数采用补码规则进行解释，这是因为对大多数的运算来说，采用补码的形式，有无符号的处理可以一致。并且无论它们之间如何转换，只要记住一个原则：位模式不变。