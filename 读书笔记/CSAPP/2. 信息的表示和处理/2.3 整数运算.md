## 2.3 整数运算
两个正数相加会得到一个负数，比较表达式$x < y$和比较表达式$x-y<0$会得到两个不同的结果。这是由于计算机运算的有限性造成的。

### 2.3.1 无符号加法
考虑两个非负整数$x$和$y$，并且$0 \le x,y < 2^w$。如果计算它们的和，就有一个可能的范围$0 \le x + y \le 2^{w+1}-2$。表示这个和可能需要$w+1$位。就需要对结果进行截断(溢出的一种情况)。
执行C程序时，不会将溢出作为错误而发出信号，需要程序员自己判断是否发生了溢出。判断方法为：对在范围$0 \le x, y \le UMax_w$中的$x$和$y$，令$x = x + y$。当且仅当$s < x$（或者等价地$s < y$）时，发生了溢出。

### 2.3.2 补码加法
对于补码加法，其位模式与无符号加法一致，同样会将计算结果截断在$w$位。对于两个符号数的加法，可能会出现几种情况：
![](pic/2.3%20整数运算/补码加法溢出.png)
举一个$w=4$的例子：
![](pic/2.3%20整数运算/补码加法例子.png)

### 2.3.3 补码的非
可以看到在范围$TMin_w \le x \le TMax_w$中的每个数字$x$都有加法逆元，即$-x$。其表达式为：
![](pic/2.3%20整数运算/补码的非.png)

### 2.3.4 无符号乘法
将两个无符号数$x$和$y$的乘积截断在$w$位，其乘积可以被表达为：
![](pic/2.3%20整数运算/无符号乘法.png)

### 2.3.5 补码乘法
对于补码乘法，将其乘积截断为$w$位相当于先计算该值的模$2^w$，再把无符号数转换位补码，即：
![](pic/2.3%20整数运算/补码乘法.png)
![](pic/2.3%20整数运算/补码乘法例子.png)

### 2.3.6 乘以常数
以往，在大多数机器上，整数乘法指令相当慢，需要10个或更多时钟周期，而其他操作(加法、减法、位级运算和移位)只需要一个周期。所以编译器使用一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。

### 2.3.7 除以2的幂
在大多数机器上，整数除法要比整数乘法更慢——需要30个或者更多的时钟周期。除以2的幂也可以用移位运算来实现，只不过用的是右移。
整数除法总是舍入到零。对于任何实数$a$，定义$|a|$为唯一的整数$a^{'}$，使得$a^{'} \le a < a^{'}+1$。

### 2.3.8 一点思考
可以看到，整数运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。补码表示提供了一种既能表示负数也能表示正数的灵活方法，同时使用了与执行无符号算数相同的位级实现，这些运算包括加法、减法、乘法、甚至除法，无论运算数是以无符号形式还是以补码形式表示的，都有完全一样或者非常类似的位级行为。

### 小结
本节介绍了关于整数的运算规则，并且解释了一些奇怪的现象，比如两个正数相加得到负数。这是因为数据只能以有限的位来表示，当某个运算结果超出了可表示的范围时，即发生了溢出，就要进行截断。无论溢出还是截断，还是其他的操作，只需要记住：位模式不变。